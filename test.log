running pytest
Searching for pytest
Best match: pytest 3.7.1
Processing pytest-3.7.1-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/pytest-3.7.1-py2.7.egg
Searching for py>=1.5.0
Best match: py 1.5.4
Processing py-1.5.4-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/py-1.5.4-py2.7.egg
Searching for pluggy>=0.7
Best match: pluggy 0.7.1
Processing pluggy-0.7.1-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/pluggy-0.7.1-py2.7.egg
Searching for pathlib2>=2.2.0
Best match: pathlib2 2.3.2
Processing pathlib2-2.3.2-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/pathlib2-2.3.2-py2.7.egg
Searching for more-itertools>=4.0.0
Best match: more-itertools 4.3.0
Processing more_itertools-4.3.0-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/more_itertools-4.3.0-py2.7.egg
Searching for attrs>=17.4.0
Best match: attrs 18.1.0
Processing attrs-18.1.0-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/attrs-18.1.0-py2.7.egg
Searching for atomicwrites>=1.0
Best match: atomicwrites 1.1.5
Processing atomicwrites-1.1.5-py2.7.egg

Using /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/.eggs/atomicwrites-1.1.5-py2.7.egg
running egg_info
writing requirements to GSLab_Make.egg-info/requires.txt
writing GSLab_Make.egg-info/PKG-INFO
writing top-level names to GSLab_Make.egg-info/top_level.txt
writing dependency_links to GSLab_Make.egg-info/dependency_links.txt
reading manifest file 'GSLab_Make.egg-info/SOURCES.txt'
writing manifest file 'GSLab_Make.egg-info/SOURCES.txt'
running build_ext
============================= test session starts ==============================
<<<<<<< HEAD
platform darwin -- Python 2.7.15, pytest-3.7.1, py-1.5.4, pluggy-0.7.1
rootdir: /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make, inifile:
collected 54 items

gslab_make_dev/tests/test_clear_dir.py ...                               [  5%]
gslab_make_dev/tests/test_execute_command.py ...                         [ 11%]
gslab_make_dev/tests/test_remove_path.py FFF.                            [ 18%]
gslab_make_dev/tests/test_run_lyx.py FF...F...F                          [ 37%]
gslab_make_dev/tests/test_run_perl.py ......                             [ 48%]
gslab_make_dev/tests/test_run_python.py ........                         [ 62%]
gslab_make_dev/tests/test_run_stata.py F.....                            [ 74%]
gslab_make_dev/tests/test_tablefill.py ....                              [ 81%]
gslab_make_dev/tests/test_textfill.py ........                           [ 96%]
gslab_make_dev/tests/test_zip.py ..                                      [100%]
=======
platform darwin -- Python 2.7.13, pytest-3.2.1, py-1.4.34, pluggy-0.4.0
rootdir: /Users/danielagonzalez/gslab_make, inifile:
collected 72 items

gslab_make/tests/test_clear_dir.py ...
gslab_make/tests/test_execute_command.py .
gslab_make/tests/test_remove_path.py .F..
gslab_make/tests/test_run_lyx.py .FFFFF.FFF
gslab_make/tests/test_run_mathematica.py .FFF.FF
gslab_make/tests/test_run_matlab.py FFFF.FF
gslab_make/tests/test_run_perl.py ......
gslab_make/tests/test_run_python.py ......
gslab_make/tests/test_run_r.py ......F.
gslab_make/tests/test_run_stata.py ......
gslab_make/tests/test_tablefill.py ....
gslab_make/tests/test_textfill.py ........
gslab_make/tests/test_zip.py ..
>>>>>>> 55820a2... fixed html parser error

=================================== FAILURES ===================================
_________________________ testRemovePath.test_default __________________________

self = <gslab_make_dev.tests.test_remove_path.testRemovePath testMethod=test_default>

    def test_default(self):
        self.assertTrue(os.path.isdir('./output_local/'))
        with nostderrout():
                remove_path('./output_local/')
>       self.assertFalse(os.path.isfile('./output_local/text.txt'))
E       AssertionError: True is not false

gslab_make_dev/tests/test_remove_path.py:27: AssertionError
______________________ testRemovePath.test_default_noisy _______________________

self = <gslab_make_dev.tests.test_remove_path.testRemovePath testMethod=test_default_noisy>

    def test_default_noisy(self):
        self.assertTrue(os.path.isfile('./output_local/text.txt'))
        with open('stdout.txt', 'w') as f:
                with redirect_stdout(f):
                        remove_path('./output_local/')
>               self.assertIn('Deleted:', open('stdout.txt').read())
E               AssertionError: 'Deleted:' not found in ''

gslab_make_dev/tests/test_remove_path.py:35: AssertionError
_________________________ testRemovePath.test_options __________________________

self = <gslab_make_dev.tests.test_remove_path.testRemovePath testMethod=test_options>

<<<<<<< HEAD
    def test_options(self):
        self.assertTrue(os.path.isfile('./output_local/text.txt'))
        os.makedirs('./output_local/temp_dir/')
        with self.assertRaises(OSError):
>           remove_path('./output_local', option='-v')
E           AssertionError: OSError not raised
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx'
kwargs = {'doctype': 'comments'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x10902eb90>
temp_name = 'lyx_test_file_comments'
temp_program = '/Users/danielagonzalez/gslab_make/gslab_make/tests/input/lyx_test_file_comments.lyx'
beamer = False, line = '\\end_document\r\n'
>>>>>>> 55820a2... fixed html parser error

gslab_make_dev/tests/test_remove_path.py:41: AssertionError
----------------------------- Captured stdout call -----------------------------

Deleted: "/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/output_local"
--------------------------- Captured stderr teardown ---------------------------
rm: /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/output_local: No such file or directory
________________________ testRunLyx.test_bad_executable ________________________

self = <gslab_make_dev.tests.test_run_lyx.testRunLyx testMethod=test_bad_executable>

    def test_bad_executable(self):
        with nostderrout():
>           run_lyx(program = 'gslab_make_dev/tests/input/lyx_test_file.lyx', executable = 'nonexistent_lyx_executable')

gslab_make_dev/tests/test_run_lyx.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

<<<<<<< HEAD
kwargs = {'executable': 'nonexistent_lyx_executable', 'program': 'gslab_make_dev/tests/input/lyx_test_file.lyx'}
directive = <gslab_make_dev.private.programdirective.LyxDirective object at 0x1045c8a90>
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx', kwargs = {}
makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x1090eb290>
>>>>>>> 55820a2... fixed html parser error
temp_name = 'lyx_test_file'
temp_program = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.lyx'
command = 'nonexistent_lyx_executable -e pdf2 /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.lyx'
temp_pdf = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.pdf'

    def run_lyx(**kwargs): # Check
    
        try:
            directive = LyxDirective(application = 'lyx', **kwargs)
    
            # Make handout/commented LyX file
            if directive.doctype:
                temp_name = os.path.join(directive.program_name + '_' + directive.doctype)
                temp_program = os.path.join(directive.program_path, temp_name + '.lyx')
    
                beamer = False
                shutil.copy2(directive.program, temp_program)
                for line in fileinput.input(temp_program, inplace = True):
                    if r'\textclass beamer' in line:
                        beamer = True
                    elif directive.doctype == 'handout' and r'\options' in line and beamer:
                        line = line.rstrip('\n') + ', handout\n'
                    elif directive.doctype == 'comments' and r'\begin_inset Note Note' in line:
                        line = line.replace('Note Note', 'Note Greyedout')
            else:
                 temp_name = directive.program_name
                 temp_program = directive.program
    
            # Execute
            command = metadata.commands[directive.osname][directive.application] % (directive.executable, directive.option, temp_program)
            directive.execute_command(command)
            directive.write_log()
    
            # Move PDF output
            temp_pdf = os.path.join(directive.program_path, temp_name + '.pdf')
            output_pdf = os.path.join(directive.pdfout, directive.program_name + '.pdf')
    
            if temp_pdf != output_pdf:
                shutil.copy2(temp_pdf, output_pdf)
                os.remove(temp_pdf)
    
            # Remove handout/commented LyX file
            if directive.doctype:
                os.remove(temp_program)
        except Exception as e:
            print(e)
>           raise Exception
E           Exception

gslab_make_dev/run_program.py:172: Exception
___________________________ testRunLyx.test_comments ___________________________

self = <gslab_make_dev.tests.test_run_lyx.testRunLyx testMethod=test_comments>

    def test_comments(self):
        temp_dir = '../temp/'
        with nostderrout():
            clear_dir([temp_dir])
>           run_lyx(program = 'gslab_make_dev/tests/input/lyx_test_file.lyx', doctype = 'comments')

gslab_make_dev/tests/test_run_lyx.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

<<<<<<< HEAD
kwargs = {'doctype': 'comments', 'program': 'gslab_make_dev/tests/input/lyx_test_file.lyx'}
directive = <gslab_make_dev.private.programdirective.LyxDirective object at 0x1046fa990>
temp_name = 'lyx_test_file_comments'
temp_program = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_comments.lyx'
beamer = False, line = '\\end_document\r\n'
command = 'lyx -e pdf2 /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_comments.lyx'
temp_pdf = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_comments.pdf'
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx'
kwargs = {'executable': 'lyx'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x10906dfd0>
temp_name = 'lyx_test_file'
temp_program = '/Users/danielagonzalez/gslab_make/gslab_make/tests/input/lyx_test_file.lyx'
>>>>>>> 55820a2... fixed html parser error

    def run_lyx(**kwargs): # Check
    
        try:
            directive = LyxDirective(application = 'lyx', **kwargs)
    
            # Make handout/commented LyX file
            if directive.doctype:
                temp_name = os.path.join(directive.program_name + '_' + directive.doctype)
                temp_program = os.path.join(directive.program_path, temp_name + '.lyx')
    
                beamer = False
                shutil.copy2(directive.program, temp_program)
                for line in fileinput.input(temp_program, inplace = True):
                    if r'\textclass beamer' in line:
                        beamer = True
                    elif directive.doctype == 'handout' and r'\options' in line and beamer:
                        line = line.rstrip('\n') + ', handout\n'
                    elif directive.doctype == 'comments' and r'\begin_inset Note Note' in line:
                        line = line.replace('Note Note', 'Note Greyedout')
            else:
                 temp_name = directive.program_name
                 temp_program = directive.program
    
            # Execute
            command = metadata.commands[directive.osname][directive.application] % (directive.executable, directive.option, temp_program)
            directive.execute_command(command)
            directive.write_log()
    
            # Move PDF output
            temp_pdf = os.path.join(directive.program_path, temp_name + '.pdf')
            output_pdf = os.path.join(directive.pdfout, directive.program_name + '.pdf')
    
            if temp_pdf != output_pdf:
                shutil.copy2(temp_pdf, output_pdf)
                os.remove(temp_pdf)
    
            # Remove handout/commented LyX file
            if directive.doctype:
                os.remove(temp_program)
        except Exception as e:
            print(e)
>           raise Exception
E           Exception

gslab_make_dev/run_program.py:172: Exception
________________________ testRunLyx.test_handout_pdfout ________________________

self = <gslab_make_dev.tests.test_run_lyx.testRunLyx testMethod=test_handout_pdfout>

    def test_handout_pdfout(self):
        temp_dir = '../temp/'
        with nostderrout():
            clear_dir([temp_dir])
>           run_lyx(program = 'gslab_make_dev/tests/input/lyx_test_file.lyx', doctype = 'handout', pdfout = 'gslab_make_dev/tests/input/custom_outfile.pdf')

gslab_make_dev/tests/test_run_lyx.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

<<<<<<< HEAD
kwargs = {'doctype': 'handout', 'pdfout': 'gslab_make_dev/tests/input/custom_outfile.pdf', 'program': 'gslab_make_dev/tests/input/lyx_test_file.lyx'}
directive = <gslab_make_dev.private.programdirective.LyxDirective object at 0x1033cfb10>
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx'
kwargs = {'doctype': 'handout'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x1090eb850>
>>>>>>> 55820a2... fixed html parser error
temp_name = 'lyx_test_file_handout'
temp_program = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_handout.lyx'
beamer = False, line = '\\end_document\r\n'
command = 'lyx -e pdf2 /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_handout.lyx'
temp_pdf = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file_handout.pdf'

    def run_lyx(**kwargs): # Check
    
        try:
            directive = LyxDirective(application = 'lyx', **kwargs)
    
            # Make handout/commented LyX file
            if directive.doctype:
                temp_name = os.path.join(directive.program_name + '_' + directive.doctype)
                temp_program = os.path.join(directive.program_path, temp_name + '.lyx')
    
                beamer = False
                shutil.copy2(directive.program, temp_program)
                for line in fileinput.input(temp_program, inplace = True):
                    if r'\textclass beamer' in line:
                        beamer = True
                    elif directive.doctype == 'handout' and r'\options' in line and beamer:
                        line = line.rstrip('\n') + ', handout\n'
                    elif directive.doctype == 'comments' and r'\begin_inset Note Note' in line:
                        line = line.replace('Note Note', 'Note Greyedout')
            else:
                 temp_name = directive.program_name
                 temp_program = directive.program
    
            # Execute
            command = metadata.commands[directive.osname][directive.application] % (directive.executable, directive.option, temp_program)
            directive.execute_command(command)
            directive.write_log()
    
            # Move PDF output
            temp_pdf = os.path.join(directive.program_path, temp_name + '.pdf')
            output_pdf = os.path.join(directive.pdfout, directive.program_name + '.pdf')
    
            if temp_pdf != output_pdf:
                shutil.copy2(temp_pdf, output_pdf)
                os.remove(temp_pdf)
    
            # Remove handout/commented LyX file
            if directive.doctype:
                os.remove(temp_program)
        except Exception as e:
            print(e)
>           raise Exception
E           Exception

gslab_make_dev/run_program.py:172: Exception
____________________________ testRunLyx.test_pdfout ____________________________

self = <gslab_make_dev.tests.test_run_lyx.testRunLyx testMethod=test_pdfout>

    def test_pdfout(self):
        with nostderrout():
>           run_lyx(program = 'gslab_make_dev/tests/input/lyx_test_file.lyx', pdfout = 'gslab_make_dev/tests/input/custom_outfile.pdf')

gslab_make_dev/tests/test_run_lyx.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

<<<<<<< HEAD
kwargs = {'pdfout': 'gslab_make_dev/tests/input/custom_outfile.pdf', 'program': 'gslab_make_dev/tests/input/lyx_test_file.lyx'}
directive = <gslab_make_dev.private.programdirective.LyxDirective object at 0x103e860d0>
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx'
kwargs = {'log': 'log/lyx.log'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x10906d410>
>>>>>>> 55820a2... fixed html parser error
temp_name = 'lyx_test_file'
temp_program = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.lyx'
command = 'lyx -e pdf2 /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.lyx'
temp_pdf = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/lyx_test_file.pdf'

    def run_lyx(**kwargs): # Check
    
        try:
            directive = LyxDirective(application = 'lyx', **kwargs)
    
            # Make handout/commented LyX file
            if directive.doctype:
                temp_name = os.path.join(directive.program_name + '_' + directive.doctype)
                temp_program = os.path.join(directive.program_path, temp_name + '.lyx')
    
                beamer = False
                shutil.copy2(directive.program, temp_program)
                for line in fileinput.input(temp_program, inplace = True):
                    if r'\textclass beamer' in line:
                        beamer = True
                    elif directive.doctype == 'handout' and r'\options' in line and beamer:
                        line = line.rstrip('\n') + ', handout\n'
                    elif directive.doctype == 'comments' and r'\begin_inset Note Note' in line:
                        line = line.replace('Note Note', 'Note Greyedout')
            else:
                 temp_name = directive.program_name
                 temp_program = directive.program
    
            # Execute
<<<<<<< HEAD
            command = metadata.commands[directive.osname][directive.application] % (directive.executable, directive.option, temp_program)
            directive.execute_command(command)
            directive.write_log()
=======
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, temp_program)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* LyX program executed with errors: *\n%s' % error_message)
E               CritError: * LyX program executed with errors: *
E               /bin/sh: lyx: command not found

gslab_make/run_program.py:399: CritError
____________________________ testRunLyx.test_option ____________________________

self = <gslab_make.tests.test_run_lyx.testRunLyx testMethod=test_option>

    def test_option(self):
        makelog = {'makelog' : 'log/make.log', 'pdf_dir' : 'output'}
        with nostderrout():
            start_makelog(makelog)
>           run_lyx(makelog, program = 'gslab_make/tests/input/lyx_test_file.lyx', option = '-e pdf')

gslab_make/tests/test_run_lyx.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file.lyx'
kwargs = {'option': '-e pdf'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x1090eb4d0>
temp_name = 'lyx_test_file'
temp_program = '/Users/danielagonzalez/gslab_make/gslab_make/tests/input/lyx_test_file.lyx'

    def run_lyx(paths, program, **kwargs):
        """ Run LyX script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
                'pdf_dir' : str
                    Directory to write PDFs.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
        doctype : str, optional
           Type of Lyx document. Takes either `handout` and `comments`.
           Defaults to no special document type.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
        pdf_dir = paths['pdf_dir']
    
        try:
            direct = LyXDirective(pdf_dir = pdf_dir, application = 'lyx', program = program, makelog = makelog, **kwargs)
>>>>>>> 55820a2... fixed html parser error
    
            # Move PDF output
            temp_pdf = os.path.join(directive.program_path, temp_name + '.pdf')
            output_pdf = os.path.join(directive.pdfout, directive.program_name + '.pdf')
    
            if temp_pdf != output_pdf:
                shutil.copy2(temp_pdf, output_pdf)
                os.remove(temp_pdf)
    
            # Remove handout/commented LyX file
            if directive.doctype:
                os.remove(temp_program)
        except Exception as e:
            print(e)
>           raise Exception
E           Exception

gslab_make_dev/run_program.py:172: Exception
_______________________ testRunStata.test_bad_executable _______________________

self = <gslab_make_dev.tests.test_run_stata.testRunStata testMethod=test_bad_executable>

    def test_bad_executable(self):
        with nostderrout():
>           run_stata(program = 'gslab_make_dev/tests/input/stata_test_script.do', executable = 'nonexistent_stata_executable')

gslab_make_dev/tests/test_run_stata.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

<<<<<<< HEAD
kwargs = {'executable': 'nonexistent_stata_executable', 'program': 'gslab_make_dev/tests/input/stata_test_script.do'}
directive = <gslab_make_dev.private.programdirective.ProgramDirective object at 0x103279610>
program_log = '/Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/stata_test_script.log'
command = 'nonexistent_stata_executable -e do /Users/jacob/Documents/School/Stanford/RA/Gentzkow/gslab_make/gslab_make_dev/tests/input/stata_test_script.do'
e = CritError()
=======
paths = {'makelog': 'log/make.log', 'pdf_dir': 'output'}
program = 'gslab_make/tests/input/lyx_test_file copy.lyx'
kwargs = {'executable': 'lyx'}, makelog = 'log/make.log', pdf_dir = 'output'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x10906dc50>
temp_name = 'lyx_test_file copy'
temp_program = '/Users/danielagonzalez/gslab_make/gslab_make/tests/input/lyx_test_file copy.lyx'
>>>>>>> 55820a2... fixed html parser error

    def run_stata(**kwargs):
        """ Run Stata script.
    
        Parameters
        ----------
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to False.
        makelog : str, optional
            Path of makelog. Defaults to path specified in metadata.
        log : str, optional
            Path of program log. Program log is only written if specified.
<<<<<<< HEAD
=======
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
        doctype : str, optional
           Type of Lyx document. Takes either `handout` and `comments`.
           Defaults to no special document type.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
        pdf_dir = paths['pdf_dir']
    
        try:
            direct = LyXDirective(pdf_dir = pdf_dir, application = 'lyx', program = program, makelog = makelog, **kwargs)
    
            # Make handout/commented LyX file
            if direct.doctype:
                temp_name = os.path.join(direct.program_name + '_' + direct.doctype)
                temp_program = os.path.join(direct.program_dir, temp_name + '.lyx')
    
                beamer = False
                shutil.copy2(direct.program, temp_program)
    
                for line in fileinput.input(temp_program, inplace = True):
                    if r'\textclass beamer' in line:
                        beamer = True
                    if direct.doctype == 'handout' and r'\options' in line and beamer:
                        line = line.rstrip('\n') + ', handout\n'
                    elif direct.doctype == 'comments' and r'\begin_inset Note Note' in line:
                        line = line.replace('Note Note', 'Note Greyedout')
                    print(line)
            else:
                temp_name = direct.program_name
                temp_program = direct.program
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, temp_program)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* LyX program executed with errors: *\n%s' % error_message)
E               CritError: * LyX program executed with errors: *
E               /bin/sh: lyx: command not found

gslab_make/run_program.py:399: CritError
____________________________ testRunLyx.test_pdfout ____________________________

self = <gslab_make.tests.test_run_lyx.testRunLyx testMethod=test_pdfout>

    def test_pdfout(self):
        makelog = {'makelog' : 'log/make.log', 'pdf_dir' : 'log'}
        with nostderrout():
            start_makelog(makelog)
>           run_lyx(makelog, program = 'gslab_make/tests/input/lyx_test_file.lyx')

gslab_make/tests/test_run_lyx.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log', 'pdf_dir': 'log'}
program = 'gslab_make/tests/input/lyx_test_file.lyx', kwargs = {}
makelog = 'log/make.log', pdf_dir = 'log'
direct = <gslab_make.private.programdirective.LyXDirective object at 0x10909d050>
temp_name = 'lyx_test_file'
temp_program = '/Users/danielagonzalez/gslab_make/gslab_make/tests/input/lyx_test_file.lyx'

    def run_lyx(paths, program, **kwargs):
        """ Run LyX script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
                'pdf_dir' : str
                    Directory to write PDFs.
            }
>>>>>>> 55820a2... fixed html parser error
        program : str
            Path of script to run.
        executable : str, optional
            Executable to use for shell command. Defaults to executable specified in metadata.
        option : str
            Options for shell command. Defaults to options specified in metadata.
        args : str
            Only used for Python and Perl scripts.
    
        Returns
        -------
        None
        """
    
        try:
            directive = ProgramDirective(application = 'stata', **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), directive.program_name + '.log')
    
            # Execute
<<<<<<< HEAD
            command = metadata.commands[directive.osname]['stata'] % (directive.executable, directive.option, directive.program)
            directive.execute_command(command)
            directive.write_log()
            directive.move_program_output(program_log, directive.log)
        except Exception as e:
            print(e)
>           raise Exception
E           Exception

gslab_make_dev/run_program.py:55: Exception
===================== 8 failed, 46 passed in 18.57 seconds =====================
Name                                           Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------------
gslab_make_dev/create_links.py                    17     17      0      0     0%   2-46
gslab_make_dev/dir_mod.py                         46      4     20      2    88%   21-22, 69, 75, 66->69, 74->75
gslab_make_dev/private/exceptionclasses.py        13      0      0      0   100%
gslab_make_dev/private/linkdirective.py          104    104     32      0     0%   2-149
gslab_make_dev/private/messages.py                20      0      0      0   100%
gslab_make_dev/private/metadata.py                 8      0      0      0   100%
gslab_make_dev/private/programdirective.py       105      6     26      7    90%   32, 56, 97, 122, 140-141, 31->32, 54->60, 55->56, 96->97, 120->126, 121->122, 127->exit
gslab_make_dev/private/utility.py                 33     16      6      0    44%   26-39, 43-48
gslab_make_dev/refactor_tests.py                  20     20      0      0     0%   2-36
gslab_make_dev/run_program.py                    123     50     14      4    61%   60-72, 105-114, 119-128, 145, 147, 169, 177-186, 191-205, 216-218, 144->145, 146->147, 163->168, 168->169
gslab_make_dev/tablefill.py                      141      5     68     10    93%   53, 105, 138, 171, 174, 32->35, 35->37, 52->53, 83->exit, 91->88, 104->105, 122->119, 137->138, 167->171, 173->174
gslab_make_dev/tablefill_info.py                   0      0      0      0   100%
gslab_make_dev/tests/nostderrout.py               12      0      2      0   100%
gslab_make_dev/tests/test_clear_dir.py            41      2      8      1    94%   55-56, 54->55
gslab_make_dev/tests/test_delete_files.py          0      0      0      0   100%
gslab_make_dev/tests/test_execute_command.py      84      8     16      7    83%   17-20, 31, 52, 72, 98-99, 15->17, 28->31, 49->52, 69->72, 92->94, 94->exit, 97->98
gslab_make_dev/tests/test_make_links.py            0      0      0      0   100%
gslab_make_dev/tests/test_remove_path.py          50      7      6      2    84%   28, 42-45, 62-63, 56->58, 61->62
gslab_make_dev/tests/test_run_lyx.py             101     19     14      4    78%   60-64, 81-84, 91-94, 101-104, 116, 119-120, 107->109, 109->111, 115->116, 118->119
gslab_make_dev/tests/test_run_mathematica.py       0      0      0      0   100%
gslab_make_dev/tests/test_run_matlab.py            0      0      0      0   100%
gslab_make_dev/tests/test_run_perl.py             59      3     10      4    90%   68, 71-72, 61->63, 63->65, 67->68, 70->71
gslab_make_dev/tests/test_run_python.py           69      3     10      4    91%   80, 83-84, 73->75, 75->77, 79->80, 82->83
gslab_make_dev/tests/test_run_r.py                 0      0      0      0   100%
gslab_make_dev/tests/test_run_stata.py            55      5     10      5    85%   49, 62, 64, 67-68, 57->59, 59->61, 61->62, 63->64, 66->67
gslab_make_dev/tests/test_tablefill.py            96      2     42      6    94%   143-144, 20->exit, 37->34, 57->43, 74->exit, 138->exit, 142->143
gslab_make_dev/tests/test_textfill.py             83      2     12      3    95%   138-139, 17->exit, 133->exit, 137->138
gslab_make_dev/tests/test_zip.py                  36      2      4      2    90%   46-47, 42->exit, 45->46
gslab_make_dev/textfill.py                       135      2     60      5    96%   44, 170, 32->35, 35->37, 43->44, 100->exit, 169->170
gslab_make_dev/textfill_info.py                    0      0      0      0   100%
gslab_make_dev/write_link_logs.py                 18     11      2      0    35%   43-49, 54-60
gslab_make_dev/write_logs.py                     111     81     26      0    22%   18-26, 36-37, 49-66, 69-83, 87-106, 113-121, 125-135, 139-157
------------------------------------------------------------------------------------------
TOTAL                                           1580    369    388     66    74%
=======
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, temp_program)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* LyX program executed with errors: *\n%s' % error_message)
E               CritError: * LyX program executed with errors: *
E               /bin/sh: lyx: command not found

gslab_make/run_program.py:399: CritError
_____________________ testRunMathematica.test_default_log ______________________

self = <gslab_make.tests.test_run_mathematica.testRunMathematica testMethod=test_default_log>

    def test_default_log(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_mathematica(makelog, program = 'gslab_make/tests/input/mathematica_test_script.m')

gslab_make/tests/test_run_mathematica.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/mathematica_test_script.m', kwargs = {}
makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x109085b90>
command = 'math < "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/mathematica_test_script.m" -noprompt'
exit_code = 127
error_message = "********************************************************************************
Error with `run_mathematica`
*******...s: *\n%s' % error_message)
CritError: * Mathematica program executed with errors: *
/bin/sh: math: command not found

"

    def run_mathematica(paths, program, **kwargs):
        """ Run Mathematica script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'math', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.program, direct.option)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* Mathematica program executed with errors: *\n%s' % error_message)
E               CritError: * Mathematica program executed with errors: *
E               /bin/sh: math: command not found

gslab_make/run_program.py:273: CritError
______________________ testRunMathematica.test_executable ______________________

self = <gslab_make.tests.test_run_mathematica.testRunMathematica testMethod=test_executable>

    def test_executable(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_mathematica(makelog, program = 'gslab_make/tests/input/mathematica_test_script.m', executable = metadata.default_executables[os.name]['math'])

gslab_make/tests/test_run_mathematica.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/mathematica_test_script.m'
kwargs = {'executable': 'math'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x10909dc10>
command = 'math < "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/mathematica_test_script.m" -noprompt'
exit_code = 127
error_message = "********************************************************************************
Error with `run_mathematica`
*******...s: *\n%s' % error_message)
CritError: * Mathematica program executed with errors: *
/bin/sh: math: command not found

"

    def run_mathematica(paths, program, **kwargs):
        """ Run Mathematica script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'math', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.program, direct.option)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* Mathematica program executed with errors: *\n%s' % error_message)
E               CritError: * Mathematica program executed with errors: *
E               /bin/sh: math: command not found

gslab_make/run_program.py:273: CritError
___________________ testRunMathematica.test_independent_log ____________________

self = <gslab_make.tests.test_run_mathematica.testRunMathematica testMethod=test_independent_log>

    def test_independent_log(self):
        makelog = {'makelog' : 'log/make.log'}
        independent_log = {'makelog' : 'log/mathematica.log'}
        with nostderrout():
>           run_mathematica(makelog, program = 'gslab_make/tests/input/mathematica_test_script.m')

gslab_make/tests/test_run_mathematica.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/mathematica_test_script.m', kwargs = {}
makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x10909a210>
command = 'math < "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/mathematica_test_script.m" -noprompt'
exit_code = 127
error_message = "********************************************************************************
Error with `run_mathematica`
*******...s: *\n%s' % error_message)
CritError: * Mathematica program executed with errors: *
/bin/sh: math: command not found

"

    def run_mathematica(paths, program, **kwargs):
        """ Run Mathematica script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'math', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.program, direct.option)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* Mathematica program executed with errors: *\n%s' % error_message)
E               CritError: * Mathematica program executed with errors: *
E               /bin/sh: math: command not found

gslab_make/run_program.py:273: CritError
________________________ testRunMathematica.test_option ________________________

self = <gslab_make.tests.test_run_mathematica.testRunMathematica testMethod=test_option>

    def test_option(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_mathematica(makelog, program = 'gslab_make/tests/input/mathematica_test_script.m', option = '-initfile gslab_make/tests/input/mathematica_init_script.m')

gslab_make/tests/test_run_mathematica.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/mathematica_test_script.m'
kwargs = {'option': '-initfile gslab_make/tests/input/mathematica_init_script.m'}
makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x109085e90>
command = 'math < "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/mathematica_test_script.m" -initfile gslab_make/tests/input/mathematica_init_script.m'
exit_code = 127
error_message = "********************************************************************************
Error with `run_mathematica`
*******...s: *\n%s' % error_message)
CritError: * Mathematica program executed with errors: *
/bin/sh: math: command not found

"

    def run_mathematica(paths, program, **kwargs):
        """ Run Mathematica script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'math', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.program, direct.option)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* Mathematica program executed with errors: *\n%s' % error_message)
E               CritError: * Mathematica program executed with errors: *
E               /bin/sh: math: command not found

gslab_make/run_program.py:273: CritError
___________________ testRunMathematica.test_path_with_space ____________________

self = <gslab_make.tests.test_run_mathematica.testRunMathematica testMethod=test_path_with_space>

    def test_path_with_space(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_mathematica(makelog, program = 'gslab_make/tests/input/mathematica_test_script copy.m', executable = metadata.default_executables[os.name]['math'])

gslab_make/tests/test_run_mathematica.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/mathematica_test_script copy.m'
kwargs = {'executable': 'math'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x1090a50d0>
command = 'math < "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/mathematica_test_script copy.m" -noprompt'
exit_code = 127
error_message = "********************************************************************************
Error with `run_mathematica`
*******...s: *\n%s' % error_message)
CritError: * Mathematica program executed with errors: *
/bin/sh: math: command not found

"

    def run_mathematica(paths, program, **kwargs):
        """ Run Mathematica script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'math', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.program, direct.option)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* Mathematica program executed with errors: *\n%s' % error_message)
E               CritError: * Mathematica program executed with errors: *
E               /bin/sh: math: command not found

gslab_make/run_program.py:273: CritError
______________________ testRunMatlab.test_bad_executable _______________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_bad_executable>

    def test_bad_executable(self):
        makelog = {'makelog' : 'log/make.log'}
>       with self.assertRaises(CritError):
E       NameError: global name 'CritError' is not defined

gslab_make/tests/test_run_matlab.py:46: NameError
________________________ testRunMatlab.test_default_log ________________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_default_log>

    def test_default_log(self):
        makelog = {'makelog' : 'log/make.log'}
>       run_matlab(makelog, program = 'gslab_make/tests/input/matlab_test_script.m')

gslab_make/tests/test_run_matlab.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/matlab_test_script.m', kwargs = {}
makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x10909d110>
program_log = '/Users/danielagonzalez/gslab_make/matlab_test_script.log'
command = 'matlab -nosplash -nodesktop -r "try run(\'/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script.m\'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script.log"'
exit_code = 127
error_message = "********************************************************************************
Error with `run_matlab`
************...rors: *\n%s' % error_message)
CritError: * Matlab program executed with errors: *
/bin/sh: matlab: command not found

"

    def run_matlab(paths, program, **kwargs):
        """ Run Matlab script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'matlab', program = program, makelog = makelog, **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), direct.program_name + '.log')
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program, direct.program_name + '.log')
            exit_code, error_message = direct.execute_command(command)
            if exit_code != 0:
>               raise CritError('* Matlab program executed with errors: *\n%s' % error_message)
E               CritError: * Matlab program executed with errors: *
E               /bin/sh: matlab: command not found

gslab_make/run_program.py:122: CritError
----------------------------- Captured stdout call -----------------------------
Executing: "matlab -nosplash -nodesktop -r "try run('/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script.m'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script.log""
________________________ testRunMatlab.test_executable _________________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_executable>

    def test_executable(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_matlab(makelog, program = 'gslab_make/tests/input/matlab_test_script.m', executable = metadata.default_executables[os.name]['matlab'])

gslab_make/tests/test_run_matlab.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/matlab_test_script.m'
kwargs = {'executable': 'matlab'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x109085990>
program_log = '/Users/danielagonzalez/gslab_make/matlab_test_script.log'
command = 'matlab -nosplash -nodesktop -r "try run(\'/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script.m\'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script.log"'
exit_code = 127
error_message = "********************************************************************************
Error with `run_matlab`
************...rors: *\n%s' % error_message)
CritError: * Matlab program executed with errors: *
/bin/sh: matlab: command not found

"

    def run_matlab(paths, program, **kwargs):
        """ Run Matlab script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'matlab', program = program, makelog = makelog, **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), direct.program_name + '.log')
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program, direct.program_name + '.log')
            exit_code, error_message = direct.execute_command(command)
            if exit_code != 0:
>               raise CritError('* Matlab program executed with errors: *\n%s' % error_message)
E               CritError: * Matlab program executed with errors: *
E               /bin/sh: matlab: command not found

gslab_make/run_program.py:122: CritError
______________________ testRunMatlab.test_independent_log ______________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_independent_log>

    def test_independent_log(self):
        makelog = {'makelog' : 'log/make.log'}
        independent_log = {'makelog' : 'log/matlab.log'}
        with nostderrout():
>           run_matlab(makelog, program = 'gslab_make/tests/input/matlab_test_script.m', log=independent_log['makelog'])

gslab_make/tests/test_run_matlab.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/matlab_test_script.m'
kwargs = {'log': 'log/matlab.log'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x1090a50d0>
program_log = '/Users/danielagonzalez/gslab_make/matlab_test_script.log'
command = 'matlab -nosplash -nodesktop -r "try run(\'/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script.m\'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script.log"'
exit_code = 127
error_message = "********************************************************************************
Error with `run_matlab`
************...rors: *\n%s' % error_message)
CritError: * Matlab program executed with errors: *
/bin/sh: matlab: command not found

"

    def run_matlab(paths, program, **kwargs):
        """ Run Matlab script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'matlab', program = program, makelog = makelog, **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), direct.program_name + '.log')
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program, direct.program_name + '.log')
            exit_code, error_message = direct.execute_command(command)
            if exit_code != 0:
>               raise CritError('* Matlab program executed with errors: *\n%s' % error_message)
E               CritError: * Matlab program executed with errors: *
E               /bin/sh: matlab: command not found

gslab_make/run_program.py:122: CritError
__________________________ testRunMatlab.test_option ___________________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_option>

    def test_option(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_matlab(makelog, program = 'gslab_make/tests/input/matlab_test_script.m', option = '-h')

gslab_make/tests/test_run_matlab.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/matlab_test_script.m'
kwargs = {'option': '-h'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x1091581d0>
program_log = '/Users/danielagonzalez/gslab_make/matlab_test_script.log'
command = 'matlab -h -r "try run(\'/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script.m\'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script.log"'
exit_code = 127
error_message = "********************************************************************************
Error with `run_matlab`
************...rors: *\n%s' % error_message)
CritError: * Matlab program executed with errors: *
/bin/sh: matlab: command not found

"

    def run_matlab(paths, program, **kwargs):
        """ Run Matlab script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'matlab', program = program, makelog = makelog, **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), direct.program_name + '.log')
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program, direct.program_name + '.log')
            exit_code, error_message = direct.execute_command(command)
            if exit_code != 0:
>               raise CritError('* Matlab program executed with errors: *\n%s' % error_message)
E               CritError: * Matlab program executed with errors: *
E               /bin/sh: matlab: command not found

gslab_make/run_program.py:122: CritError
___________________________ testRunMatlab.test_wait ____________________________

self = <gslab_make.tests.test_run_matlab.testRunMatlab testMethod=test_wait>

    def test_wait(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_matlab(makelog, program = 'gslab_make/tests/input/matlab_test_script_wait1.m')

gslab_make/tests/test_run_matlab.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/matlab_test_script_wait1.m', kwargs = {}
makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x1090cc390>
program_log = '/Users/danielagonzalez/gslab_make/matlab_test_script_wait1.log'
command = 'matlab -nosplash -nodesktop -r "try run(\'/Users/danielagonzalez/gslab_make/gslab_make/tests/input/matlab_test_script_wait1.m\'); catch e, fprintf(getReport(e)), exit(1); end; exit(0)" -logfile "matlab_test_script_wait1.log"'
exit_code = 127
error_message = "********************************************************************************
Error with `run_matlab`
************...rors: *\n%s' % error_message)
CritError: * Matlab program executed with errors: *
/bin/sh: matlab: command not found

"

    def run_matlab(paths, program, **kwargs):
        """ Run Matlab script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'matlab', program = program, makelog = makelog, **kwargs)
    
            # Get program output
            program_log = os.path.join(os.getcwd(), direct.program_name + '.log')
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program, direct.program_name + '.log')
            exit_code, error_message = direct.execute_command(command)
            if exit_code != 0:
>               raise CritError('* Matlab program executed with errors: *\n%s' % error_message)
E               CritError: * Matlab program executed with errors: *
E               /bin/sh: matlab: command not found

gslab_make/run_program.py:122: CritError
________________________ testRunR.test_path_with_space _________________________

self = <gslab_make.tests.test_run_r.testRunR testMethod=test_path_with_space>

    def test_path_with_space(self):
        makelog = {'makelog' : 'log/make.log'}
        with nostderrout():
>           run_r(makelog, program = 'gslab_make/tests/input/R_test_script copy.R', executable = 'R CMD BATCH')

gslab_make/tests/test_run_r.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

paths = {'makelog': 'log/make.log'}
program = 'gslab_make/tests/input/R_test_script copy.R'
kwargs = {'executable': 'R CMD BATCH'}, makelog = 'log/make.log'
direct = <gslab_make.private.programdirective.ProgramDirective object at 0x109111a50>
command = 'R CMD BATCH --no-save "/Users/danielagonzalez/gslab_make/gslab_make/tests/input/R_test_script copy.R"'
exit_code = 2
error_message = "********************************************************************************
Error with `run_r`
*****************... CritError('* R program executed with errors: *\n%s' % error_message)
CritError: * R program executed with errors: *

"

    def run_r(paths, program, **kwargs):
        """ Run R script using system command.
    
        Parameters
        ----------
        paths : dict
            Dictionary of paths. Dictionary should contain {
                'makelog' : str
                    Path of makelog.
            }
        program : str
            Path of script to run.
        osname : str, optional
            Name of OS. Defaults to `os.name`.
        shell : bool, optional
            See: https://docs.python.org/2/library/subprocess.html#frequently-used-arguments.
            Defaults to `True`.
        log : str, optional
            Path of program log. Program log is only written if specified.
        executable : str, optional
            Executable to use for system command.
            Defaults to executable specified in metadata.
        option : str, optional
            Options for system command. Defaults to options specified in metadata.
        args : str, optional
            Not applicable.
    
        Returns
        -------
        None
        """
    
        makelog = paths['makelog']
    
        try:
            direct = ProgramDirective(application = 'r', program = program, makelog = makelog, **kwargs)
    
            # Execute
            command = metadata.commands[direct.osname][direct.application] % (direct.executable, direct.option, direct.program)
            exit_code, error_message = direct.execute_command(command)
            direct.write_log()
            if exit_code != 0:
>               raise CritError('* R program executed with errors: *\n%s' % error_message)
E               CritError: * R program executed with errors: *

gslab_make/run_program.py:461: CritError
===================== 21 failed, 51 passed in 9.98 seconds =====================
Name                                       Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------------------
gslab_make/check_links.py                     37     27      2      0    26%   29-37, 62-84
gslab_make/create_links.py                    30     20      2      0    31%   43-60, 93-95, 128-130
gslab_make/dir_mod.py                         48      4     20      2    88%   25-26, 75, 81, 72->75, 80->81
gslab_make/private/exceptionclasses.py         4      0      0      0   100%
gslab_make/private/linkdirective.py          110     82     30      0    20%   47-53, 63-64, 74-83, 93-101, 111-119, 140-147, 168-172, 182-187, 197-199, 208-215, 250-256, 266-274, 284-285, 295-301, 312-316
gslab_make/private/messages.py                23      0      0      0   100%
gslab_make/private/metadata.py                 7      0      0      0   100%
gslab_make/private/programdirective.py       107     13     32      9    84%   64, 95, 110-113, 126, 218, 264, 295-296, 337-338, 63->64, 94->95, 124->130, 125->126, 217->218, 262->268, 263->264, 269->exit, 336->337
gslab_make/private/utility.py                 46     26     12      1    36%   46-63, 82-94, 16->23
gslab_make/run_program.py                    183     45     34      6    73%   123, 313-328, 384, 386, 402-411, 503-523, 560-565, 121->123, 272->exit, 383->384, 385->386, 398->402, 559->560
gslab_make/tablefill.py                      143      5     68     10    93%   56, 108, 141, 174, 177, 35->38, 38->40, 55->56, 86->exit, 94->91, 107->108, 125->122, 140->141, 170->174, 176->177
gslab_make/tablefill_info.py                   0      0      0      0   100%
gslab_make/tests/nostderrout.py               12      0      2      0   100%
gslab_make/tests/test_clear_dir.py            41      2      8      1    94%   55-56, 54->55
gslab_make/tests/test_execute_command.py      31      3      8      4    82%   26, 39-40, 23->26, 33->35, 35->exit, 38->39
gslab_make/tests/test_remove_path.py          56      3      6      2    92%   63, 68-69, 62->63, 67->68
gslab_make/tests/test_run_lyx.py             108     32      8      4    69%   24-26, 34-39, 46-48, 55-57, 82-84, 91-94, 101-104, 111-114, 125-126, 117->119, 119->121, 121->exit, 124->125
gslab_make/tests/test_run_mathematica.py      68     15     10      5    74%   25-26, 33-36, 42-43, 49-50, 68, 76, 78, 81-82, 71->73, 73->75, 75->76, 77->78, 80->81
gslab_make/tests/test_run_matlab.py           72     23      8      3    65%   24-25, 32-35, 41-42, 47-48, 60-64, 70-73, 76-78, 87-88, 81->83, 83->exit, 86->87
gslab_make/tests/test_run_perl.py             65      2      8      3    93%   77-78, 69->71, 71->73, 76->77
gslab_make/tests/test_run_python.py           64      2      8      3    93%   76-77, 68->70, 70->72, 75->76
gslab_make/tests/test_run_r.py                79      6     12      5    88%   50-51, 88, 90, 93-94, 81->83, 83->85, 87->88, 89->90, 92->93
gslab_make/tests/test_run_stata.py            62      3      8      4    90%   71, 74-75, 66->68, 68->70, 70->71, 73->74
gslab_make/tests/test_tablefill.py            96      2     42      6    94%   143-144, 20->exit, 37->34, 57->43, 74->exit, 138->exit, 142->143
gslab_make/tests/test_textfill.py             83      2     12      3    95%   138-139, 17->exit, 133->exit, 137->138
gslab_make/tests/test_zip.py                  35      2      4      2    90%   45-46, 41->exit, 44->45
gslab_make/textfill.py                       137      2     60      5    96%   47, 173, 35->38, 38->40, 46->47, 103->exit, 172->173
gslab_make/textfill_info.py                    0      0      0      0   100%
gslab_make/write_link_logs.py                 31     23      2      0    24%   52-71, 88-95
gslab_make/write_logs.py                      88     55     22      3    33%   69-84, 111, 152-172, 197-207, 227-246, 40->exit, 107->exit, 110->111
--------------------------------------------------------------------------------------
TOTAL                                       1866    399    428     81    76%
>>>>>>> 55820a2... fixed html parser error
